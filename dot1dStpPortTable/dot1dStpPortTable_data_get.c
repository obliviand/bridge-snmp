/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot1dStpPortTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot1dStpPortTable get routines.
 * TODO:240:M: Implement dot1dStpPortTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot1dStpPortTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRIDGE-MIB::dot1dStpPortTable is subid 15 of dot1dStp.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.17.2.15, length: 9
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot1dStpPortTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param dot1dStpPort_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int dot1dStpPortTable_indexes_set_tbl_idx(dot1dStpPortTable_mib_index *tbl_idx, long dot1dStpPort_val)
{
	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_indexes_set_tbl_idx","called\n"));

	/* dot1dStpPort(1)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
	tbl_idx->dot1dStpPort = dot1dStpPort_val;
    

	return MFD_SUCCESS;
} /* dot1dStpPortTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int dot1dStpPortTable_indexes_set(dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPort_val)
{
	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_indexes_set","called\n"));

	if(MFD_SUCCESS != dot1dStpPortTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, dot1dStpPort_val))
		return MFD_ERROR;

	/*
	 * convert mib index to oid index
	 */
	rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
	if (0 != dot1dStpPortTable_index_to_oid(&rowreq_ctx->oid_idx, &rowreq_ctx->tbl_idx)) {
		return MFD_ERROR;
	}

	return MFD_SUCCESS;
} /* dot1dStpPortTable_indexes_set */


/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPriority
 * dot1dStpPortPriority is subid 2 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.2
 * Description:
The value of the priority field that is contained in
        the first (in network byte order) octet of the (2 octet
        long) Port ID.  The other octet of the Port ID is given
        by the value of dot1dStpPort.
        On bridges supporting IEEE 802.1t or IEEE 802.1w,
        permissible values are 0-240, in steps of 16.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dot1dStpPortPriority data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPriority_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortPriority_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
			     long *dot1dStpPortPriority_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortPriority_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPriority_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortPriority data.
	 * copy (*dot1dStpPortPriority_val_ptr) from rowreq_ctx->data
	 */
	(*dot1dStpPortPriority_val_ptr) = rowreq_ctx->data.dot1dStpPortPriority;

	return MFD_SUCCESS;
} /* dot1dStpPortPriority_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortState
 * dot1dStpPortState is subid 3 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.3
 * Description:
The port's current state, as defined by application of
        the Spanning Tree Protocol.  This state controls what
        action a port takes on reception of a frame.  If the
        bridge has detected a port that is malfunctioning, it
        will place that port into the broken(6) state.  For
        ports that are disabled (see dot1dStpPortEnable), this
        object will have a value of disabled(1).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  disabled(1), blocking(2), listening(3), learning(4), forwarding(5), broken(6)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the dot1dStpPortState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortState_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortState_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
			  u_long *dot1dStpPortState_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortState_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortState_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortState data.
	 * copy (* dot1dStpPortState_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dStpPortState_val_ptr) = rowreq_ctx->data.dot1dStpPortState;

	return MFD_SUCCESS;
} /* dot1dStpPortState_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortEnable
 * dot1dStpPortEnable is subid 4 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.4
 * Description:
The enabled/disabled status of the port.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  enabled(1), disabled(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the dot1dStpPortEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortEnable_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
			   u_long *dot1dStpPortEnable_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortEnable_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortEnable_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortEnable data.
	 * copy (* dot1dStpPortEnable_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dStpPortEnable_val_ptr) = rowreq_ctx->data.dot1dStpPortEnable;

	return MFD_SUCCESS;
} /* dot1dStpPortEnable_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPathCost
 * dot1dStpPortPathCost is subid 5 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.5
 * Description:
The contribution of this port to the path cost of
        paths towards the spanning tree root which include
        this port.  802.1D-1998 recommends that the default
        value of this parameter be in inverse proportion to

        the speed of the attached LAN.

        New implementations should support dot1dStpPortPathCost32.
        If the port path costs exceeds the maximum value of this
        object then this object should report the maximum value,
        namely 65535.  Applications should try to read the
        dot1dStpPortPathCost32 object if this object reports
        the maximum value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dot1dStpPortPathCost data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPathCost_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortPathCost_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
			     long *dot1dStpPortPathCost_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortPathCost_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortPathCost data.
	 * copy (* dot1dStpPortPathCost_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dStpPortPathCost_val_ptr) = rowreq_ctx->data.dot1dStpPortPathCost;

	return MFD_SUCCESS;
} /* dot1dStpPortPathCost_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortDesignatedRoot
 * dot1dStpPortDesignatedRoot is subid 6 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.6
 * Description:
The unique Bridge Identifier of the Bridge
        recorded as the Root in the Configuration BPDUs
        transmitted by the Designated Bridge for the
        segment to which the port is attached.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  8;
 *
 * Its syntax is BridgeId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 */
/**
 * Extract the current value of the dot1dStpPortDesignatedRoot data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortDesignatedRoot_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param dot1dStpPortDesignatedRoot_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by dot1dStpPortDesignatedRoot.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*dot1dStpPortDesignatedRoot_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update dot1dStpPortDesignatedRoot_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int dot1dStpPortDesignatedRoot_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
				   char **dot1dStpPortDesignatedRoot_val_ptr_ptr,
				   size_t *dot1dStpPortDesignatedRoot_val_ptr_len_ptr)
{
	/** we should have a non-NULL pointer and enough storage */
	netsnmp_assert((NULL != dot1dStpPortDesignatedRoot_val_ptr_ptr) && (NULL != *dot1dStpPortDesignatedRoot_val_ptr_ptr));
	netsnmp_assert(NULL != dot1dStpPortDesignatedRoot_val_ptr_len_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortDesignatedRoot_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortDesignatedRoot data.
	 * copy (*dot1dStpPortDesignatedRoot_val_ptr_ptr) data and (*dot1dStpPortDesignatedRoot_val_ptr_len_ptr) from rowreq_ctx->data
	 */
	/*
	 * make sure there is enough space for dot1dStpPortDesignatedRoot data
	 */
	if ((NULL == (*dot1dStpPortDesignatedRoot_val_ptr_ptr)) ||
	    ((*dot1dStpPortDesignatedRoot_val_ptr_len_ptr) <
		    (rowreq_ctx->data.dot1dStpPortDesignatedRoot_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedRoot[0])))) {
		/*
		 * allocate space for dot1dStpPortDesignatedRoot data
		 */
		(*dot1dStpPortDesignatedRoot_val_ptr_ptr) = malloc(rowreq_ctx->data.dot1dStpPortDesignatedRoot_len * 
									sizeof(rowreq_ctx->data.dot1dStpPortDesignatedRoot[0]));
		if (NULL == (*dot1dStpPortDesignatedRoot_val_ptr_ptr)) {
			snmp_log(LOG_ERR,"could not allocate memory for dot1dStpPortDesignatedRoot\n");
			return MFD_ERROR;
		}
	}
	(*dot1dStpPortDesignatedRoot_val_ptr_len_ptr ) = rowreq_ctx->data.dot1dStpPortDesignatedRoot_len *
								sizeof(rowreq_ctx->data.dot1dStpPortDesignatedRoot[0]);
	memcpy((*dot1dStpPortDesignatedRoot_val_ptr_ptr),
		rowreq_ctx->data.dot1dStpPortDesignatedRoot,
		rowreq_ctx->data.dot1dStpPortDesignatedRoot_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedRoot[0]));

	return MFD_SUCCESS;
} /* dot1dStpPortDesignatedRoot_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortDesignatedCost
 * dot1dStpPortDesignatedCost is subid 7 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.7
 * Description:
The path cost of the Designated Port of the segment
        connected to this port.  This value is compared to the
        Root Path Cost field in received bridge PDUs.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dot1dStpPortDesignatedCost data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortDesignatedCost_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortDesignatedCost_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
				   long *dot1dStpPortDesignatedCost_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortDesignatedCost_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortDesignatedCost_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortDesignatedCost data.
	 * copy (*dot1dStpPortDesignatedCost_val_ptr) from rowreq_ctx->data
	 */
	(*dot1dStpPortDesignatedCost_val_ptr) = rowreq_ctx->data.dot1dStpPortDesignatedCost;

	return MFD_SUCCESS;
} /* dot1dStpPortDesignatedCost_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortDesignatedBridge
 * dot1dStpPortDesignatedBridge is subid 8 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.8
 * Description:
The Bridge Identifier of the bridge that this
        port considers to be the Designated Bridge for
        this port's segment.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  8;
 *
 * Its syntax is BridgeId (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 8)
 */
/**
 * Extract the current value of the dot1dStpPortDesignatedBridge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortDesignatedBridge_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param dot1dStpPortDesignatedBridge_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by dot1dStpPortDesignatedBridge.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*dot1dStpPortDesignatedBridge_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update dot1dStpPortDesignatedBridge_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int dot1dStpPortDesignatedBridge_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
				     char **dot1dStpPortDesignatedBridge_val_ptr_ptr,
				     size_t *dot1dStpPortDesignatedBridge_val_ptr_len_ptr)
{
	/** we should have a non-NULL pointer and enough storage */
	netsnmp_assert((NULL != dot1dStpPortDesignatedBridge_val_ptr_ptr) && (NULL != *dot1dStpPortDesignatedBridge_val_ptr_ptr));
	netsnmp_assert(NULL != dot1dStpPortDesignatedBridge_val_ptr_len_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortDesignatedBridge_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortDesignatedBridge data.
	 * copy (*dot1dStpPortDesignatedBridge_val_ptr_ptr) data and (*dot1dStpPortDesignatedBridge_val_ptr_len_ptr) from rowreq_ctx->data
	 */
	/*
	 * make sure there is enough space for dot1dStpPortDesignatedBridge data
	 */
	if ((NULL == (*dot1dStpPortDesignatedBridge_val_ptr_ptr)) ||
		((*dot1dStpPortDesignatedBridge_val_ptr_len_ptr) <
			(rowreq_ctx->data.dot1dStpPortDesignatedBridge_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedBridge[0])))) {
		/*
		 * allocate space for dot1dStpPortDesignatedBridge data
		 */
		(*dot1dStpPortDesignatedBridge_val_ptr_ptr) = 
			malloc(rowreq_ctx->data.dot1dStpPortDesignatedBridge_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedBridge[0]));
		if(NULL == (*dot1dStpPortDesignatedBridge_val_ptr_ptr)) {
			snmp_log(LOG_ERR,"could not allocate memory for dot1dStpPortDesignatedBridge\n");
			return MFD_ERROR;
		}
	}
	(*dot1dStpPortDesignatedBridge_val_ptr_len_ptr) = rowreq_ctx->data.dot1dStpPortDesignatedBridge_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedBridge[0]);
	memcpy((*dot1dStpPortDesignatedBridge_val_ptr_ptr),
		rowreq_ctx->data.dot1dStpPortDesignatedBridge,
		rowreq_ctx->data.dot1dStpPortDesignatedBridge_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedBridge[0]));

	return MFD_SUCCESS;
} /* dot1dStpPortDesignatedBridge_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortDesignatedPort
 * dot1dStpPortDesignatedPort is subid 9 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.9
 * Description:
The Port Identifier of the port on the Designated
        Bridge for this port's segment.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  2;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 2)
 */
/**
 * Extract the current value of the dot1dStpPortDesignatedPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortDesignatedPort_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param dot1dStpPortDesignatedPort_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by dot1dStpPortDesignatedPort.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*dot1dStpPortDesignatedPort_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update dot1dStpPortDesignatedPort_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int dot1dStpPortDesignatedPort_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
				   char **dot1dStpPortDesignatedPort_val_ptr_ptr,
				   size_t *dot1dStpPortDesignatedPort_val_ptr_len_ptr)
{
	/** we should have a non-NULL pointer and enough storage */
	netsnmp_assert((NULL != dot1dStpPortDesignatedPort_val_ptr_ptr) && (NULL != *dot1dStpPortDesignatedPort_val_ptr_ptr));
	netsnmp_assert(NULL != dot1dStpPortDesignatedPort_val_ptr_len_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortDesignatedPort_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortDesignatedPort data.
	 * copy (* dot1dStpPortDesignatedPort_val_ptr_ptr ) data and (* dot1dStpPortDesignatedPort_val_ptr_len_ptr ) from rowreq_ctx->data
	 */
	/*
	 * make sure there is enough space for dot1dStpPortDesignatedPort data
	 */
	if ((NULL == (*dot1dStpPortDesignatedPort_val_ptr_ptr )) ||
		((*dot1dStpPortDesignatedPort_val_ptr_len_ptr) <
			(rowreq_ctx->data.dot1dStpPortDesignatedPort_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedPort[0])))) {
		/*
		 * allocate space for dot1dStpPortDesignatedPort data
		 */
		(*dot1dStpPortDesignatedPort_val_ptr_ptr) = 
			malloc(rowreq_ctx->data.dot1dStpPortDesignatedPort_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedPort[0]));
		if (NULL == (*dot1dStpPortDesignatedPort_val_ptr_ptr)) {
			snmp_log(LOG_ERR,"could not allocate memory for dot1dStpPortDesignatedPort\n");
			return MFD_ERROR;
		}
	}
	(*dot1dStpPortDesignatedPort_val_ptr_len_ptr) = rowreq_ctx->data.dot1dStpPortDesignatedPort_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedPort[0]);
	memcpy((*dot1dStpPortDesignatedPort_val_ptr_ptr),
		rowreq_ctx->data.dot1dStpPortDesignatedPort,
		rowreq_ctx->data.dot1dStpPortDesignatedPort_len * sizeof(rowreq_ctx->data.dot1dStpPortDesignatedPort[0]));

	return MFD_SUCCESS;
} /* dot1dStpPortDesignatedPort_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortForwardTransitions
 * dot1dStpPortForwardTransitions is subid 10 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.2.15.1.10
 * Description:
The number of times this port has transitioned
        from the Learning state to the Forwarding state.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the dot1dStpPortForwardTransitions data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortForwardTransitions_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortForwardTransitions_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
				       u_long *dot1dStpPortForwardTransitions_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortForwardTransitions_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortForwardTransitions_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortForwardTransitions data.
	 * copy (* dot1dStpPortForwardTransitions_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dStpPortForwardTransitions_val_ptr) = rowreq_ctx->data.dot1dStpPortForwardTransitions;

	return MFD_SUCCESS;
} /* dot1dStpPortForwardTransitions_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPathCost32
 * dot1dStpPortPathCost32 is subid 11 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.11
 * Description:
The contribution of this port to the path cost of
        paths towards the spanning tree root which include
        this port.  802.1D-1998 recommends that the default
        value of this parameter be in inverse proportion to
        the speed of the attached LAN.

        This object replaces dot1dStpPortPathCost to support
        IEEE 802.1t.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 200000000;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dot1dStpPortPathCost32 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPathCost32_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dStpPortPathCost32_get(dot1dStpPortTable_rowreq_ctx *rowreq_ctx,
			       long *dot1dStpPortPathCost32_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dStpPortPathCost32_val_ptr);


	DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost32_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dStpPortPathCost32 data.
	 * copy (* dot1dStpPortPathCost32_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dStpPortPathCost32_val_ptr) = rowreq_ctx->data.dot1dStpPortPathCost32;

	return MFD_SUCCESS;
} /* dot1dStpPortPathCost32_get */

/** @} */
