/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.19 $ of : mfd-data-set.m2c,v $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot1dStpPortTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot1dStpPortTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRIDGE-MIB::dot1dStpPortTable is subid 15 of dot1dStp.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.17.2.15, length: 9
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * dot1dStpPortTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * dot1dStpPortTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot1dStpPortTable_undo_setup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup dot1dStpPortTable undo.
     * set up dot1dStpPortTable undo information, in preparation for a set.
     * Undo storage is in (* dot1dStpPortPathCost32_val_ptr )*
     */

    return rc;
} /* dot1dStpPortTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot1dStpPortTable_undo( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> dot1dStpPortTable undo.
     * dot1dStpPortTable undo information, in response to a failed set.
     * Undo storage is in (* dot1dStpPortPathCost32_val_ptr )*
     */

    return rc;
} /* dot1dStpPortTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot1dStpPortTable_undo_cleanup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup dot1dStpPortTable undo.
     * Undo storage is in (* dot1dStpPortPathCost32_val_ptr )*
     */

    return rc;
} /* dot1dStpPortTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot1dStpPortTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot1dStpPortTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot1dStpPortTable_commit( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit dot1dStpPortTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_DOT1DSTPPORTPRIORITY_FLAG) {
       save_flags &= ~COLUMN_DOT1DSTPPORTPRIORITY_FLAG; /* clear dot1dStpPortPriority */
       /*
        * TODO:482:o: |-> commit column dot1dStpPortPriority.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot1dStpPortTable column dot1dStpPortPriority commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot1dStpPortPriority
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT1DSTPPORTPRIORITY_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT1DSTPPORTENABLE_FLAG) {
       save_flags &= ~COLUMN_DOT1DSTPPORTENABLE_FLAG; /* clear dot1dStpPortEnable */
       /*
        * TODO:482:o: |-> commit column dot1dStpPortEnable.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot1dStpPortTable column dot1dStpPortEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot1dStpPortEnable
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT1DSTPPORTENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT1DSTPPORTPATHCOST_FLAG) {
       save_flags &= ~COLUMN_DOT1DSTPPORTPATHCOST_FLAG; /* clear dot1dStpPortPathCost */
       /*
        * TODO:482:o: |-> commit column dot1dStpPortPathCost.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot1dStpPortTable column dot1dStpPortPathCost commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot1dStpPortPathCost
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT1DSTPPORTPATHCOST_FLAG;
       }
    }

    if (save_flags & COLUMN_DOT1DSTPPORTPATHCOST32_FLAG) {
       save_flags &= ~COLUMN_DOT1DSTPPORTPATHCOST32_FLAG; /* clear dot1dStpPortPathCost32 */
       /*
        * TODO:482:o: |-> commit column dot1dStpPortPathCost32.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot1dStpPortTable column dot1dStpPortPathCost32 commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo dot1dStpPortPathCost32
             */
            rowreq_ctx->column_set_flags |= COLUMN_DOT1DSTPPORTPATHCOST32_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* dot1dStpPortTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot1dStpPortTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot1dStpPortTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot1dStpPortTable_undo_commit( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo dot1dStpPortTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* dot1dStpPortTable_undo_commit */

/*
 * TODO:440:M: Implement dot1dStpPortTable node value checks.
 * TODO:450:M: Implement dot1dStpPortTable undo functions.
 * TODO:460:M: Implement dot1dStpPortTable set functions.
 * TODO:480:M: Implement dot1dStpPortTable commit functions.
 */
/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPriority
 * dot1dStpPortPriority is subid 2 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.2
 * Description:
The value of the priority field that is contained in
        the first (in network byte order) octet of the (2 octet
        long) Port ID.  The other octet of the Port ID is given
        by the value of dot1dStpPort.
        On bridges supporting IEEE 802.1t or IEEE 802.1w,
        permissible values are 0-240, in steps of 16.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPriority_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot1dStpPortTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot1dStpPortPriority_check_value( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPriority_val)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPriority_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot1dStpPortPriority value.
     */

    return MFD_SUCCESS; /* dot1dStpPortPriority value not illegal */
} /* dot1dStpPortPriority_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot1dStpPortTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot1dStpPortPriority_undo_setup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPriority_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot1dStpPortPriority undo.
     */
    /*
     * copy dot1dStpPortPriority data
     * set rowreq_ctx->undo->dot1dStpPortPriority from rowreq_ctx->data.dot1dStpPortPriority
     */
    rowreq_ctx->undo->dot1dStpPortPriority = rowreq_ctx->data.dot1dStpPortPriority;


    return MFD_SUCCESS;
} /* dot1dStpPortPriority_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot1dStpPortPriority_val
 *        A long containing the new value.
 */
int
dot1dStpPortPriority_set( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPriority_val )
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPriority_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot1dStpPortPriority value.
     * set dot1dStpPortPriority value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot1dStpPortPriority = dot1dStpPortPriority_val;

    return MFD_SUCCESS;
} /* dot1dStpPortPriority_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot1dStpPortPriority_undo( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPriority_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot1dStpPortPriority undo.
     */
    /*
     * copy dot1dStpPortPriority data
     * set rowreq_ctx->data.dot1dStpPortPriority from rowreq_ctx->undo->dot1dStpPortPriority
     */
    rowreq_ctx->data.dot1dStpPortPriority = rowreq_ctx->undo->dot1dStpPortPriority;

    
    return MFD_SUCCESS;
} /* dot1dStpPortPriority_undo */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortEnable
 * dot1dStpPortEnable is subid 4 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.4
 * Description:
The enabled/disabled status of the port.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  enabled(1), disabled(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot1dStpPortTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  enabled(1), disabled(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot1dStpPortEnable_check_value( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, u_long dot1dStpPortEnable_val)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot1dStpPortEnable value.
     */

    return MFD_SUCCESS; /* dot1dStpPortEnable value not illegal */
} /* dot1dStpPortEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot1dStpPortTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot1dStpPortEnable_undo_setup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot1dStpPortEnable undo.
     */
    /*
     * copy dot1dStpPortEnable data
     * set rowreq_ctx->undo->dot1dStpPortEnable from rowreq_ctx->data.dot1dStpPortEnable
     */
    rowreq_ctx->undo->dot1dStpPortEnable = rowreq_ctx->data.dot1dStpPortEnable;


    return MFD_SUCCESS;
} /* dot1dStpPortEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot1dStpPortEnable_val
 *        A long containing the new value.
 */
int
dot1dStpPortEnable_set( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, u_long dot1dStpPortEnable_val )
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot1dStpPortEnable value.
     * set dot1dStpPortEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot1dStpPortEnable = dot1dStpPortEnable_val;

    return MFD_SUCCESS;
} /* dot1dStpPortEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot1dStpPortEnable_undo( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot1dStpPortEnable undo.
     */
    /*
     * copy dot1dStpPortEnable data
     * set rowreq_ctx->data.dot1dStpPortEnable from rowreq_ctx->undo->dot1dStpPortEnable
     */
    rowreq_ctx->data.dot1dStpPortEnable = rowreq_ctx->undo->dot1dStpPortEnable;

    
    return MFD_SUCCESS;
} /* dot1dStpPortEnable_undo */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPathCost
 * dot1dStpPortPathCost is subid 5 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.5
 * Description:
The contribution of this port to the path cost of
        paths towards the spanning tree root which include
        this port.  802.1D-1998 recommends that the default
        value of this parameter be in inverse proportion to

        the speed of the attached LAN.

        New implementations should support dot1dStpPortPathCost32.
        If the port path costs exceeds the maximum value of this
        object then this object should report the maximum value,
        namely 65535.  Applications should try to read the
        dot1dStpPortPathCost32 object if this object reports
        the maximum value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPathCost_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot1dStpPortTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot1dStpPortPathCost_check_value( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPathCost_val)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot1dStpPortPathCost value.
     */

    return MFD_SUCCESS; /* dot1dStpPortPathCost value not illegal */
} /* dot1dStpPortPathCost_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot1dStpPortTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot1dStpPortPathCost_undo_setup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot1dStpPortPathCost undo.
     */
    /*
     * copy dot1dStpPortPathCost data
     * set rowreq_ctx->undo->dot1dStpPortPathCost from rowreq_ctx->data.dot1dStpPortPathCost
     */
    rowreq_ctx->undo->dot1dStpPortPathCost = rowreq_ctx->data.dot1dStpPortPathCost;


    return MFD_SUCCESS;
} /* dot1dStpPortPathCost_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot1dStpPortPathCost_val
 *        A long containing the new value.
 */
int
dot1dStpPortPathCost_set( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPathCost_val )
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot1dStpPortPathCost value.
     * set dot1dStpPortPathCost value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot1dStpPortPathCost = dot1dStpPortPathCost_val;

    return MFD_SUCCESS;
} /* dot1dStpPortPathCost_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot1dStpPortPathCost_undo( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot1dStpPortPathCost undo.
     */
    /*
     * copy dot1dStpPortPathCost data
     * set rowreq_ctx->data.dot1dStpPortPathCost from rowreq_ctx->undo->dot1dStpPortPathCost
     */
    rowreq_ctx->data.dot1dStpPortPathCost = rowreq_ctx->undo->dot1dStpPortPathCost;

    
    return MFD_SUCCESS;
} /* dot1dStpPortPathCost_undo */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dStpPortEntry.dot1dStpPortPathCost32
 * dot1dStpPortPathCost32 is subid 11 of dot1dStpPortEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.2.1.17.2.15.1.11
 * Description:
The contribution of this port to the path cost of
        paths towards the spanning tree root which include
        this port.  802.1D-1998 recommends that the default
        value of this parameter be in inverse proportion to
        the speed of the attached LAN.

        This object replaces dot1dStpPortPathCost to support
        IEEE 802.1t.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 200000000;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dStpPortPathCost32_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot1dStpPortTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 200000000
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
dot1dStpPortPathCost32_check_value( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPathCost32_val)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost32_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid dot1dStpPortPathCost32 value.
     */

    return MFD_SUCCESS; /* dot1dStpPortPathCost32 value not illegal */
} /* dot1dStpPortPathCost32_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot1dStpPortTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot1dStpPortTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
dot1dStpPortPathCost32_undo_setup( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost32_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup dot1dStpPortPathCost32 undo.
     */
    /*
     * copy dot1dStpPortPathCost32 data
     * set rowreq_ctx->undo->dot1dStpPortPathCost32 from rowreq_ctx->data.dot1dStpPortPathCost32
     */
    rowreq_ctx->undo->dot1dStpPortPathCost32 = rowreq_ctx->data.dot1dStpPortPathCost32;


    return MFD_SUCCESS;
} /* dot1dStpPortPathCost32_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param dot1dStpPortPathCost32_val
 *        A long containing the new value.
 */
int
dot1dStpPortPathCost32_set( dot1dStpPortTable_rowreq_ctx *rowreq_ctx, long dot1dStpPortPathCost32_val )
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost32_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set dot1dStpPortPathCost32 value.
     * set dot1dStpPortPathCost32 value in rowreq_ctx->data
     */
    rowreq_ctx->data.dot1dStpPortPathCost32 = dot1dStpPortPathCost32_val;

    return MFD_SUCCESS;
} /* dot1dStpPortPathCost32_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
dot1dStpPortPathCost32_undo( dot1dStpPortTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot1dStpPortTable:dot1dStpPortPathCost32_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up dot1dStpPortPathCost32 undo.
     */
    /*
     * copy dot1dStpPortPathCost32 data
     * set rowreq_ctx->data.dot1dStpPortPathCost32 from rowreq_ctx->undo->dot1dStpPortPathCost32
     */
    rowreq_ctx->data.dot1dStpPortPathCost32 = rowreq_ctx->undo->dot1dStpPortPathCost32;

    
    return MFD_SUCCESS;
} /* dot1dStpPortPathCost32_undo */

/** @} */
