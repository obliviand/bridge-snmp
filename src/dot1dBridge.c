/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.9 2005/01/07 09:37:18 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "ctl_functions.h"
#include "dot1dBridge.h"

long dot1dStpPriority = 1;
long dot1dStpBridgeMaxAge = -1;
long dot1dStpBridgeHelloTime = -1;
long dot1dStpBridgeForwardDelay = -1;
int dot1dStpVersion = -1;
int dot1dStpTxHoldCount = -1;
int dot1dTpAgeingTime = -1;

/** Initializes the dot1dBridge module */
void init_dot1dBridge(void)
{
	static oid dot1dBaseBridgeAddress_oid[] = { 1, 3, 6, 1, 2, 1, 17, 1, 1 };
	static oid dot1dBaseNumPorts_oid[] = { 1, 3, 6, 1, 2, 1, 17, 1, 2 };
	static oid dot1dBaseType_oid[] = { 1, 3, 6, 1, 2, 1, 17, 1, 3 };
	static oid dot1dStpProtocolSpecification_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 1 };
	static oid dot1dStpPriority_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 2 };
	static oid dot1dStpTimeSinceTopologyChange_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 3 };
	static oid dot1dStpTopChanges_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 4 };
	static oid dot1dStpDesignatedRoot_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 5 };
	static oid dot1dStpRootCost_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 6 };
	static oid dot1dStpRootPort_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 7 };
	static oid dot1dStpMaxAge_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 8 };
	static oid dot1dStpHelloTime_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 9 };
	static oid dot1dStpHoldTime_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 10 };
	static oid dot1dStpForwardDelay_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 11 };
	static oid dot1dStpBridgeMaxAge_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 12 };
	static oid dot1dStpBridgeHelloTime_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 13 };
	static oid dot1dStpBridgeForwardDelay_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 14 };
	static oid dot1dStpVersion_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 16 };
	static oid dot1dStpTxHoldCount_oid[] = { 1, 3, 6, 1, 2, 1, 17, 2, 17 };
	static oid dot1dTpLearnedEntryDiscards_oid[] = { 1, 3, 6, 1, 2, 1, 17, 4, 1 };
	static oid dot1dTpAgingTime_oid[] = { 1, 3, 6, 1, 2, 1, 17, 4, 2 };

	DEBUGMSGTL(("dot1dBridge", "Initializing\n"));

	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dBaseBridgeAddress",
	                handle_dot1dBaseBridgeAddress,
	                dot1dBaseBridgeAddress_oid,
	                OID_LENGTH(dot1dBaseBridgeAddress_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dBaseNumPorts", handle_dot1dBaseNumPorts,
	                dot1dBaseNumPorts_oid,
	                OID_LENGTH(dot1dBaseNumPorts_oid), HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dBaseType", handle_dot1dBaseType,
	                dot1dBaseType_oid, OID_LENGTH(dot1dBaseType_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpProtocolSpecification",
	                handle_dot1dStpProtocolSpecification,
	                dot1dStpProtocolSpecification_oid,
	                OID_LENGTH(dot1dStpProtocolSpecification_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpPriority", handle_dot1dStpPriority,
	                dot1dStpPriority_oid, OID_LENGTH(dot1dStpPriority_oid),
	                HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpTimeSinceTopologyChange",
	                handle_dot1dStpTimeSinceTopologyChange,
	                dot1dStpTimeSinceTopologyChange_oid,
	                OID_LENGTH(dot1dStpTimeSinceTopologyChange_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpTopChanges", handle_dot1dStpTopChanges,
	                dot1dStpTopChanges_oid,
	                OID_LENGTH(dot1dStpTopChanges_oid), HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpDesignatedRoot",
	                handle_dot1dStpDesignatedRoot,
	                dot1dStpDesignatedRoot_oid,
	                OID_LENGTH(dot1dStpDesignatedRoot_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpRootCost", handle_dot1dStpRootCost,
	                dot1dStpRootCost_oid, OID_LENGTH(dot1dStpRootCost_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpRootPort", handle_dot1dStpRootPort,
	                dot1dStpRootPort_oid, OID_LENGTH(dot1dStpRootPort_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpMaxAge", handle_dot1dStpMaxAge,
	                dot1dStpMaxAge_oid, OID_LENGTH(dot1dStpMaxAge_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpHelloTime", handle_dot1dStpHelloTime,
	                dot1dStpHelloTime_oid,
	                OID_LENGTH(dot1dStpHelloTime_oid), HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpHoldTime", handle_dot1dStpHoldTime,
	                dot1dStpHoldTime_oid, OID_LENGTH(dot1dStpHoldTime_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpForwardDelay", handle_dot1dStpForwardDelay,
	                dot1dStpForwardDelay_oid,
	                OID_LENGTH(dot1dStpForwardDelay_oid), HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpBridgeMaxAge", handle_dot1dStpBridgeMaxAge,
	                dot1dStpBridgeMaxAge_oid,
	                OID_LENGTH(dot1dStpBridgeMaxAge_oid),
	                HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpBridgeHelloTime",
	                handle_dot1dStpBridgeHelloTime,
	                dot1dStpBridgeHelloTime_oid,
	                OID_LENGTH(dot1dStpBridgeHelloTime_oid),
	                HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpBridgeForwardDelay",
	                handle_dot1dStpBridgeForwardDelay,
	                dot1dStpBridgeForwardDelay_oid,
	                OID_LENGTH(dot1dStpBridgeForwardDelay_oid),
	                HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpVersion",
	                handle_dot1dStpVersion,
	                dot1dStpVersion_oid,
	                OID_LENGTH(dot1dStpVersion_oid),
	                HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dStpTxHoldCount",
	                handle_dot1dStpTxHoldCount,
	                dot1dStpTxHoldCount_oid,
	                OID_LENGTH(dot1dStpTxHoldCount_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dTpLearnedEntryDiscards",
	                handle_dot1dTpLearnedEntryDiscards,
	                dot1dTpLearnedEntryDiscards_oid,
	                OID_LENGTH(dot1dTpLearnedEntryDiscards_oid),
	                HANDLER_CAN_RONLY));
	netsnmp_register_scalar(netsnmp_create_handler_registration(
	                "dot1dTpAgingTime", handle_dot1dTpAgingTime,
	                dot1dTpAgingTime_oid, OID_LENGTH(dot1dTpAgingTime_oid),
	                HANDLER_CAN_RWRITE));
}

int get_index_die(const char *ifname, const char *doc, int die)
{
	int r = if_nametoindex(ifname);
	if (r == 0) {
		snmp_log(LOG_ERR,
			"Can't find index for %s %s. Not a valid interface.\n",
			doc, ifname);
		if (die)
			exit(1);
		return SNMP_ERR_GENERR;
	}
	return r;
}

int handle_dot1dBaseBridgeAddress(netsnmp_mib_handler *handler,
				  netsnmp_handler_registration *reginfo,
				  netsnmp_agent_request_info *reqinfo,
				  netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {
		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
					(u_char *)&uid_state.bridge_id.addr,
					sizeof(uid_state.bridge_id.addr));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dBaseBridgeAddress\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int not_dot_dotdot(const struct dirent *entry)
{
	const char *n = entry->d_name;

	return !(n[0] == '.' && (n[1] == 0 || (n[1] == '.' && n[2] == 0)));
}

int handle_dot1dBaseNumPorts(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
	int count = 0;
	char buf[SYSFS_PATH_MAX];
	struct dirent **namelist;

	snprintf(buf, sizeof(buf), SYSFS_CLASS_NET "/%s/brif", bridge_name);
	count = scandir(buf, &namelist, not_dot_dotdot, alphasort);
	if (count < 0) {
		snmp_log(LOG_ERR,
			"Error getting list of all ports of bridge %s\n",
			bridge_name);
		return SNMP_ERR_GENERR;
	}
	
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&count,
					sizeof(count));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dBaseNumPorts\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dBaseType(netsnmp_mib_handler *handler,
			 netsnmp_handler_registration *reginfo,
			 netsnmp_agent_request_info *reqinfo,
			 netsnmp_request_info *requests)
{
	int type = 2; /* Force to transparent only */
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&type,
					sizeof(type));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dBaseType\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpProtocolSpecification(netsnmp_mib_handler *handler,
					 netsnmp_handler_registration *reginfo,
					 netsnmp_agent_request_info *reqinfo,
					 netsnmp_request_info *requests)
{
	int protocol = 3; /* Force ieee8021d protocol */
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&protocol,
					sizeof(protocol));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpProtocolSpecification\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpPriority(netsnmp_mib_handler *handler,
			    netsnmp_handler_registration *reginfo,
			    netsnmp_agent_request_info *reqinfo,
			    netsnmp_request_info *requests)
{
	int ret;
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&uid_state.bridge_id.prio,
					sizeof(uid_state.bridge_id.prio));
			break;

			/*
			 * SET REQUEST
			 *
			 * multiple states in the transaction.  See:
			 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
			 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb,
							ASN_INTEGER);
			if (ret != SNMP_ERR_NOERROR) {
				netsnmp_set_request_error(reqinfo, requests,
						ret);
			}
			break;

		case MODE_SET_RESERVE2:
			dot1dStpPriority = uid_cfg.bridge_priority;
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			uid_cfg.bridge_priority = *requests->requestvb->val.integer;
			ret = CTL_set_bridge_config(br_index, &uid_cfg);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dStpPriority != 1) {
				uid_cfg.bridge_priority = dot1dStpPriority;
				ret = CTL_set_bridge_config(br_index, &uid_cfg);

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}

			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpPriority\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpTimeSinceTopologyChange(netsnmp_mib_handler *handler,
					   netsnmp_handler_registration *reginfo,
					   netsnmp_agent_request_info *reqinfo,
					   netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int topology_change_time = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			topology_change_time = uid_state.Time_Since_Topology_Change * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
					(u_char *)&topology_change_time,
					sizeof(topology_change_time));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpTimeSinceTopologyChange\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpTopChanges(netsnmp_mib_handler *handler,
			      netsnmp_handler_registration *reginfo,
			      netsnmp_agent_request_info *reqinfo,
			      netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
					(u_char *)&uid_state.Topology_Change_Count,
					uid_state.Topology_Change_Count);
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpTopChanges\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpDesignatedRoot(netsnmp_mib_handler *handler,
				  netsnmp_handler_registration *reginfo,
				  netsnmp_agent_request_info *reqinfo,
				  netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}
	
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
					(u_char *)&uid_state.designated_root,
					sizeof(uid_state.designated_root));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpDesignatedRoot\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpRootCost(netsnmp_mib_handler *handler,
			    netsnmp_handler_registration *reginfo,
			    netsnmp_agent_request_info *reqinfo,
			    netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&uid_state.root_path_cost,
					sizeof(uid_state.root_path_cost));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpRootCost\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpRootPort(netsnmp_mib_handler *handler,
			    netsnmp_handler_registration *reginfo,
			    netsnmp_agent_request_info *reqinfo,
			    netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	long root_port = 0;
	
	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			if ((long)uid_state.root_port > 0) {
				root_port = (long)uid_state.root_port - 0x8000;
			} else {
				root_port = (long)uid_state.root_port;
			}
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&root_port,
					sizeof(root_port));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpRootPort\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpMaxAge(netsnmp_mib_handler *handler,
			  netsnmp_handler_registration *reginfo,
			  netsnmp_agent_request_info *reqinfo,
			  netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int max_age = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			max_age = uid_state.max_age * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&max_age,
					sizeof(max_age));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpMaxAge\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpHelloTime(netsnmp_mib_handler *handler,
			     netsnmp_handler_registration *reginfo,
			     netsnmp_agent_request_info *reqinfo,
			     netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int hello_time = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			hello_time = uid_state.hello_time * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&hello_time,
					sizeof(hello_time));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpHelloTime\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpHoldTime(netsnmp_mib_handler *handler,
			    netsnmp_handler_registration *reginfo,
			    netsnmp_agent_request_info *reqinfo,
			    netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int hold_time = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			hold_time = uid_cfg.hold_time * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&hold_time,
					sizeof(hold_time));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpHoldTime\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpForwardDelay(netsnmp_mib_handler *handler,
				netsnmp_handler_registration *reginfo,
				netsnmp_agent_request_info *reqinfo,
				netsnmp_request_info *requests)
{
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int forward_delay = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			forward_delay = uid_state.forward_delay * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&forward_delay,
					sizeof(forward_delay));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpForwardDelay\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}
int handle_dot1dStpBridgeMaxAge(netsnmp_mib_handler *handler,
				netsnmp_handler_registration *reginfo,
				netsnmp_agent_request_info *reqinfo,
				netsnmp_request_info *requests)
{
	int ret;
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int max_age = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			max_age = uid_cfg.max_age * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&max_age,
					sizeof(max_age));
			break;

			/*
			 * SET REQUEST
			 *
			 * multiple states in the transaction.  See:
			 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
			 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
			if (ret != SNMP_ERR_NOERROR) {
				netsnmp_set_request_error(reqinfo, requests, ret);
			}
			break;

		case MODE_SET_RESERVE2:
			dot1dStpBridgeMaxAge = uid_cfg.max_age;
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			uid_cfg.max_age = (*requests->requestvb->val.integer)/100;
			ret = CTL_set_bridge_config(br_index, &uid_cfg);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dStpBridgeMaxAge != -1) {
				uid_cfg.max_age = dot1dStpBridgeMaxAge;
				ret = CTL_set_bridge_config(br_index, &uid_cfg);

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpBridgeMaxAge\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_dot1dStpBridgeHelloTime(netsnmp_mib_handler *handler,
				   netsnmp_handler_registration *reginfo,
				   netsnmp_agent_request_info *reqinfo,
				   netsnmp_request_info *requests)
{
	int ret;
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int hello_time = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			hello_time = uid_cfg.hello_time * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&hello_time,
					sizeof(hello_time));
			break;

			/*
			 * SET REQUEST
			 *
			 * multiple states in the transaction.  See:
			 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
			 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb,
			                ASN_INTEGER);
			if (ret != SNMP_ERR_NOERROR ) {
				netsnmp_set_request_error(reqinfo, requests,
					ret);
			}
			break;

		case MODE_SET_RESERVE2:
			dot1dStpBridgeHelloTime = uid_cfg.hello_time;
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			uid_cfg.hello_time = (*requests->requestvb->val.integer)/100;
			ret = CTL_set_bridge_config(br_index, &uid_cfg);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dStpBridgeHelloTime != -1) {
				uid_cfg.hello_time = dot1dStpBridgeHelloTime;
				ret = CTL_set_bridge_config(br_index, &uid_cfg);

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpBridgeHelloTime\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
		}

		return SNMP_ERR_NOERROR;
	}
int handle_dot1dStpBridgeForwardDelay(netsnmp_mib_handler *handler,
				      netsnmp_handler_registration *reginfo,
				      netsnmp_agent_request_info *reqinfo,
				      netsnmp_request_info *requests)
{
	int ret;
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int forward_delay = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			forward_delay = uid_cfg.forward_delay * 100;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&forward_delay,
					sizeof(forward_delay));
			break;

		/*
		 * SET REQUEST
		 *
		 * multiple states in the transaction.  See:
		 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
		 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb,
						ASN_INTEGER);
			if (ret != SNMP_ERR_NOERROR ) {
				netsnmp_set_request_error(reqinfo, requests,
						ret);
			}
			break;

		case MODE_SET_RESERVE2:
			dot1dStpBridgeForwardDelay = uid_cfg.forward_delay;
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			uid_cfg.forward_delay = (*requests->requestvb->val.integer)/100;
			ret = CTL_set_bridge_config(br_index, &uid_cfg);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dStpBridgeForwardDelay != -1) {
				uid_cfg.forward_delay = dot1dStpBridgeForwardDelay;
				ret = CTL_set_bridge_config(br_index, &uid_cfg);

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				"unknown mode (%d) in handle_dot1dStpBridgeForwardDelay\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_dot1dStpVersion(netsnmp_mib_handler *handler,
			   netsnmp_handler_registration *reginfo,
			   netsnmp_agent_request_info *reqinfo,
			   netsnmp_request_info *requests)
{
	int ret;
	UID_STP_STATE_T uid_state;
	UID_STP_CFG_T uid_cfg;
	int version = 0;

	int br_index = get_index_die(bridge_name, "bridge", 0);
	if (br_index == SNMP_ERR_GENERR)
		return br_index;

	int r = CTL_get_bridge_state(br_index, &uid_cfg, &uid_state);
	if (r) {
		snmp_log(LOG_ERR,
			"Failed to get bridge state: %s\n",
			CTL_error_explanation(r));
		return SNMP_ERR_GENERR;
	}

	/* We are never called for a GETNEXT if it's registered as a
	   "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	   we don't need to loop over a list of requests; we'll only get one. */
    
	switch(reqinfo->mode) {
		case MODE_GET:
			version = uid_cfg.force_version;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
						 (u_char *)&version,
						 sizeof(version));
			break;

		/*
		 * SET REQUEST
		 *
		 * multiple states in the transaction.  See:
		 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
		 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
			if ( ret != SNMP_ERR_NOERROR ) {
				netsnmp_set_request_error(reqinfo, requests, ret );
			}
			break;

		case MODE_SET_RESERVE2:
			dot1dStpVersion = uid_cfg.force_version;
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			uid_cfg.force_version = (*requests->requestvb->val.integer);
			ret = CTL_set_bridge_config(br_index, &uid_cfg);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dStpVersion != -1) {
				uid_cfg.force_version = dot1dStpVersion;
				ret = CTL_set_bridge_config(br_index, &uid_cfg);

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot1dStpVersion\n", reqinfo->mode );
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_dot1dStpTxHoldCount(netsnmp_mib_handler *handler,
			       netsnmp_handler_registration *reginfo,
			       netsnmp_agent_request_info *reqinfo,
			       netsnmp_request_info *requests)
{
	int ret;
	
	/* We are never called for a GETNEXT if it's registered as a
	   "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	   we don't need to loop over a list of requests; we'll only get one. */
    
	switch(reqinfo->mode) {
		case MODE_GET:
			dot1dStpTxHoldCount = 3;
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
						 (u_char *)&dot1dStpTxHoldCount,
						 sizeof(dot1dStpTxHoldCount));
			break;
		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				 "unknown mode (%d) in handle_dot1dStpTxHoldCount\n",
				 reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_dot1dTpLearnedEntryDiscards(netsnmp_mib_handler *handler,
				       netsnmp_handler_registration *reginfo,
				       netsnmp_agent_request_info *reqinfo,
				       netsnmp_request_info *requests)
{
	long learned_entry_discards = 0;
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
					(u_char *)&learned_entry_discards,
					sizeof(learned_entry_discards));
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
			        "unknown mode (%d) in handle_dot1dTpLearnedEntryDiscards\n",
			        reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_dot1dTpAgingTime(netsnmp_mib_handler *handler,
			    netsnmp_handler_registration *reginfo,
			    netsnmp_agent_request_info *reqinfo,
			    netsnmp_request_info *requests)
{
	int ret;
	char path[SYSFS_PATH_MAX];
	struct sysfs_attribute *ageing_time;
	

	snprintf(path, sizeof(path), SYSFS_CLASS_NET "/%s/bridge/ageing_time", bridge_name);
	if ((ageing_time = sysfs_open_attribute(path)) == NULL) {
		sysfs_close_attribute(ageing_time);
		snmp_log(LOG_ERR,
			 "could not open ageing_time in sysfs for bridge %s\n",
			 bridge_name);
		return SNMP_ERR_GENERR;
	}

	if (sysfs_read_attribute(ageing_time) == -1) {
		snmp_log(LOG_ERR,
			 "could not read ageing_time in sysfs for bridge %s\n",
			 bridge_name);
		return SNMP_ERR_GENERR;	
	}
	
	/* We are never called for a GETNEXT if it's registered as a
	 "instance", as it's "magically" handled for us.  */

	/* a instance handler also only hands us one request at a time, so
	 we don't need to loop over a list of requests; we'll only get one. */

	switch (reqinfo->mode) {

		case MODE_GET:
			sscanf(ageing_time->value, "%u", &dot1dTpAgeingTime);
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					(u_char *)&dot1dTpAgeingTime,
					sizeof(dot1dTpAgeingTime));
			break;

		/*
		 * SET REQUEST
		 *
		 * multiple states in the transaction.  See:
		 * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
		 */
		case MODE_SET_RESERVE1:
			/* or you could use netsnmp_check_vb_type_and_size instead */
			ret = netsnmp_check_vb_type(requests->requestvb,
						ASN_INTEGER);
			if (ret != SNMP_ERR_NOERROR ) {
				netsnmp_set_request_error(reqinfo, requests,
						ret);
			}
			break;

		case MODE_SET_RESERVE2:
			sscanf(ageing_time->value, "%u", &dot1dTpAgeingTime);
			break;

		case MODE_SET_FREE:
			break;

		case MODE_SET_ACTION:
			ret = sysfs_write_attribute(ageing_time, (char *)requests->requestvb->val.integer,
						requests->requestvb->val_len);

			if (0 != ret) {
				netsnmp_set_request_error(reqinfo, requests, ret);
				snmp_log(LOG_ERR,
					"Can't change rstp bridge %s:%s\n", bridge_name,
					STP_IN_get_error_explanation(ret));				
			}
			
			break;

		case MODE_SET_COMMIT:
			break;

		case MODE_SET_UNDO:
			if (dot1dTpAgeingTime != -1) {
				ret = sysfs_write_attribute(ageing_time, (char *)&dot1dTpAgeingTime,
							sizeof(dot1dTpAgeingTime));

				if (0 != ret) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
				}
			}
			break;

		default:
			/* we should never get here, so this is a really bad error */
			snmp_log(LOG_ERR,
				 "unknown mode (%d) in handle_dot1dTpAgingTime\n",
				 reqinfo->mode);
			return SNMP_ERR_GENERR;
	}

	sysfs_close_attribute(ageing_time);
	return SNMP_ERR_NOERROR;
}
