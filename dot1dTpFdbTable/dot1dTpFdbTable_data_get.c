/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot1dTpFdbTable.h"

/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot1dTpFdbTable get routines.
 * TODO:240:M: Implement dot1dTpFdbTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot1dTpFdbTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * BRIDGE-MIB::dot1dTpFdbTable is subid 3 of dot1dTp.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.17.4.3, length: 9
 */

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot1dTpFdbTable data context functions.
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param dot1dTpFdbAddress_ptr
 * @param dot1dTpFdbAddress_ptr_len
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int dot1dTpFdbTable_indexes_set_tbl_idx(dot1dTpFdbTable_mib_index *tbl_idx,
					char *dot1dTpFdbAddress_val_ptr,
					size_t dot1dTpFdbAddress_val_ptr_len)
{
	DEBUGMSGTL(("verbose:dot1dTpFdbTable:dot1dTpFdbTable_indexes_set_tbl_idx","called\n"));

	/* dot1dTpFdbAddress(1)/MacAddress/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H		*/
	tbl_idx->dot1dTpFdbAddress_len = sizeof(tbl_idx->dot1dTpFdbAddress)/sizeof(tbl_idx->dot1dTpFdbAddress[0]); /* max length */
	/*
	 * make sure there is enough space for dot1dTpFdbAddress data
	 */
	if ((NULL == tbl_idx->dot1dTpFdbAddress) ||
		(tbl_idx->dot1dTpFdbAddress_len <
			(dot1dTpFdbAddress_val_ptr_len))) {
		snmp_log(LOG_ERR,"not enough space for value\n");
		return MFD_ERROR;
	}
	tbl_idx->dot1dTpFdbAddress_len = dot1dTpFdbAddress_val_ptr_len;
	memcpy(tbl_idx->dot1dTpFdbAddress, dot1dTpFdbAddress_val_ptr,
		dot1dTpFdbAddress_val_ptr_len * sizeof(dot1dTpFdbAddress_val_ptr[0]));

	return MFD_SUCCESS;
} /* dot1dTpFdbTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, the nupdates the oid indexs
 *from the mib index.
 */
int dot1dTpFdbTable_indexes_set(dot1dTpFdbTable_rowreq_ctx *rowreq_ctx,
				char *dot1dTpFdbAddress_val_ptr,
				size_t dot1dTpFdbAddress_val_ptr_len)
{
	DEBUGMSGTL(("verbose:dot1dTpFdbTable:dot1dTpFdbTable_indexes_set","called\n"));

	if(MFD_SUCCESS !=
		dot1dTpFdbTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
			dot1dTpFdbAddress_val_ptr, dot1dTpFdbAddress_val_ptr_len))
		return MFD_ERROR;

	/*
	 * convert mib index to oid index
	 */
	rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
	if(0 != dot1dTpFdbTable_index_to_oid(&rowreq_ctx->oid_idx,
			&rowreq_ctx->tbl_idx)) {
		return MFD_ERROR;
	}

	return MFD_SUCCESS;
} /* dot1dTpFdbTable_indexes_set */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dTpFdbEntry.dot1dTpFdbPort
 * dot1dTpFdbPort is subid 2 of dot1dTpFdbEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.4.3.1.2
 * Description:
 Either the value '0', or the port number of the port on
 which a frame having a source address equal to the value
 of the corresponding instance of dot1dTpFdbAddress has
 been seen.  A value of '0' indicates that the port
 number has not been learned, but that the bridge does
 have some forwarding/filtering information about this
 address (e.g., in the dot1dStaticTable).  Implementors
 are encouraged to assign the port value to this object
 whenever it is learned, even for addresses for which the
 corresponding value of dot1dTpFdbStatus is not
 learned(3).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dot1dTpFdbPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dTpFdbPort_val_ptr
* Pointer to storage for a long variable
*
* @retval MFD_SUCCESS : success
* @retval MFD_SKIP : skip this node (no value for now)
* @retval MFD_ERROR : Any other error
*/
int dot1dTpFdbPort_get(dot1dTpFdbTable_rowreq_ctx *rowreq_ctx,
		       long *dot1dTpFdbPort_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dTpFdbPort_val_ptr);

	DEBUGMSGTL(("verbose:dot1dTpFdbTable:dot1dTpFdbPort_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dTpFdbPort data.
	 * copy (* dot1dTpFdbPort_val_ptr ) from rowreq_ctx->data
	 */
	(*dot1dTpFdbPort_val_ptr) = rowreq_ctx->data.dot1dTpFdbPort;

	return MFD_SUCCESS;
} /* dot1dTpFdbPort_get */

/*---------------------------------------------------------------------
 * BRIDGE-MIB::dot1dTpFdbEntry.dot1dTpFdbStatus
 * dot1dTpFdbStatus is subid 3 of dot1dTpFdbEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.17.4.3.1.3
 * Description:
 The status of this entry.  The meanings of the
 values are:
 other(1) - none of the following.  This would
 include the case where some other MIB object
 (not the corresponding instance of
 dot1dTpFdbPort, nor an entry in the
 dot1dStaticTable) is being used to determine if
 and how frames addressed to the value of the
 corresponding instance of dot1dTpFdbAddress are
 being forwarded.
 invalid(2) - this entry is no longer valid (e.g.,
 it was learned but has since aged out), but has
 not yet been flushed from the table.
 learned(3) - the value of the corresponding instance
 of dot1dTpFdbPort was learned, and is being
 used.
 self(4) - the value of the corresponding instance of
 dot1dTpFdbAddress represents one of the bridge's
 addresses.  The corresponding instance of
 dot1dTpFdbPort indicates which of the bridge's
 ports has this address.
 mgmt(5) - the value of the corresponding instance of
 dot1dTpFdbAddress is also the value of an
 existing instance of dot1dStaticAddress.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4/8. Values:  other(1), invalid(2), learned(3), self(4), mgmt(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type dec lis long (u_long)
*/
/**
 * Extract the current value of the dot1dTpFdbStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dot1dTpFdbStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int dot1dTpFdbStatus_get(dot1dTpFdbTable_rowreq_ctx *rowreq_ctx,
			 u_long *dot1dTpFdbStatus_val_ptr)
{
	/** we should have a non-NULL pointer */
	netsnmp_assert(NULL != dot1dTpFdbStatus_val_ptr);

	DEBUGMSGTL(("verbose:dot1dTpFdbTable:dot1dTpFdbStatus_get","called\n"));

	netsnmp_assert(NULL != rowreq_ctx);

	/*
	 * TODO:231:o: |-> Extract the current value of the dot1dTpFdbStatus data.
	 * copy (*dot1dTpFdbStatus_val_ptr) from rowreq_ctx->data
	 */
	(*dot1dTpFdbStatus_val_ptr) = rowreq_ctx->data.dot1dTpFdbStatus;

	return MFD_SUCCESS;
} /* dot1dTpFdbStatus_get */

/** @} */
